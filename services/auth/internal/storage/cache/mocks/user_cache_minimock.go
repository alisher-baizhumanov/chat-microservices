// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/alisher-baizhumanov/chat-microservices/services/auth/internal/storage/cache.UserCache -o user_cache_minimock.go -n UserCacheMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/alisher-baizhumanov/chat-microservices/services/auth/internal/model"
	"github.com/gojuno/minimock/v3"
)

// UserCacheMock implements cache.UserCache
type UserCacheMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDelete          func(ctx context.Context, id int64) (err error)
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mUserCacheMockDelete

	funcGet          func(ctx context.Context, id int64) (u1 model.User, err error)
	inspectFuncGet   func(ctx context.Context, id int64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mUserCacheMockGet

	funcSet          func(ctx context.Context, user model.User) (err error)
	inspectFuncSet   func(ctx context.Context, user model.User)
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mUserCacheMockSet
}

// NewUserCacheMock returns a mock for cache.UserCache
func NewUserCacheMock(t minimock.Tester) *UserCacheMock {
	m := &UserCacheMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteMock = mUserCacheMockDelete{mock: m}
	m.DeleteMock.callArgs = []*UserCacheMockDeleteParams{}

	m.GetMock = mUserCacheMockGet{mock: m}
	m.GetMock.callArgs = []*UserCacheMockGetParams{}

	m.SetMock = mUserCacheMockSet{mock: m}
	m.SetMock.callArgs = []*UserCacheMockSetParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserCacheMockDelete struct {
	optional           bool
	mock               *UserCacheMock
	defaultExpectation *UserCacheMockDeleteExpectation
	expectations       []*UserCacheMockDeleteExpectation

	callArgs []*UserCacheMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserCacheMockDeleteExpectation specifies expectation struct of the UserCache.Delete
type UserCacheMockDeleteExpectation struct {
	mock      *UserCacheMock
	params    *UserCacheMockDeleteParams
	paramPtrs *UserCacheMockDeleteParamPtrs
	results   *UserCacheMockDeleteResults
	Counter   uint64
}

// UserCacheMockDeleteParams contains parameters of the UserCache.Delete
type UserCacheMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// UserCacheMockDeleteParamPtrs contains pointers to parameters of the UserCache.Delete
type UserCacheMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserCacheMockDeleteResults contains results of the UserCache.Delete
type UserCacheMockDeleteResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mUserCacheMockDelete) Optional() *mUserCacheMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for UserCache.Delete
func (mmDelete *mUserCacheMockDelete) Expect(ctx context.Context, id int64) *mUserCacheMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserCacheMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserCacheMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("UserCacheMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &UserCacheMockDeleteParams{ctx, id}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for UserCache.Delete
func (mmDelete *mUserCacheMockDelete) ExpectCtxParam1(ctx context.Context) *mUserCacheMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserCacheMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserCacheMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserCacheMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserCacheMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for UserCache.Delete
func (mmDelete *mUserCacheMockDelete) ExpectIdParam2(id int64) *mUserCacheMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserCacheMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserCacheMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserCacheMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserCacheMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the UserCache.Delete
func (mmDelete *mUserCacheMockDelete) Inspect(f func(ctx context.Context, id int64)) *mUserCacheMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for UserCacheMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by UserCache.Delete
func (mmDelete *mUserCacheMockDelete) Return(err error) *UserCacheMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserCacheMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserCacheMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &UserCacheMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the UserCache.Delete method
func (mmDelete *mUserCacheMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *UserCacheMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the UserCache.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the UserCache.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the UserCache.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mUserCacheMockDelete) When(ctx context.Context, id int64) *UserCacheMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserCacheMock.Delete mock is already set by Set")
	}

	expectation := &UserCacheMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &UserCacheMockDeleteParams{ctx, id},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up UserCache.Delete return parameters for the expectation previously defined by the When method
func (e *UserCacheMockDeleteExpectation) Then(err error) *UserCacheMock {
	e.results = &UserCacheMockDeleteResults{err}
	return e.mock
}

// Times sets number of times UserCache.Delete should be invoked
func (mmDelete *mUserCacheMockDelete) Times(n uint64) *mUserCacheMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of UserCacheMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	return mmDelete
}

func (mmDelete *mUserCacheMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements cache.UserCache
func (mmDelete *UserCacheMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := UserCacheMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := UserCacheMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("UserCacheMock.Delete got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("UserCacheMock.Delete got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("UserCacheMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the UserCacheMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to UserCacheMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished UserCacheMock.Delete invocations
func (mmDelete *UserCacheMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of UserCacheMock.Delete invocations
func (mmDelete *UserCacheMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to UserCacheMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mUserCacheMockDelete) Calls() []*UserCacheMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*UserCacheMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *UserCacheMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *UserCacheMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCacheMock.Delete with params: %#v", *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserCacheMock.Delete")
		} else {
			m.t.Errorf("Expected call to UserCacheMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Error("Expected call to UserCacheMock.Delete")
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCacheMock.Delete but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), afterDeleteCounter)
	}
}

type mUserCacheMockGet struct {
	optional           bool
	mock               *UserCacheMock
	defaultExpectation *UserCacheMockGetExpectation
	expectations       []*UserCacheMockGetExpectation

	callArgs []*UserCacheMockGetParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserCacheMockGetExpectation specifies expectation struct of the UserCache.Get
type UserCacheMockGetExpectation struct {
	mock      *UserCacheMock
	params    *UserCacheMockGetParams
	paramPtrs *UserCacheMockGetParamPtrs
	results   *UserCacheMockGetResults
	Counter   uint64
}

// UserCacheMockGetParams contains parameters of the UserCache.Get
type UserCacheMockGetParams struct {
	ctx context.Context
	id  int64
}

// UserCacheMockGetParamPtrs contains pointers to parameters of the UserCache.Get
type UserCacheMockGetParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserCacheMockGetResults contains results of the UserCache.Get
type UserCacheMockGetResults struct {
	u1  model.User
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mUserCacheMockGet) Optional() *mUserCacheMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for UserCache.Get
func (mmGet *mUserCacheMockGet) Expect(ctx context.Context, id int64) *mUserCacheMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserCacheMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserCacheMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("UserCacheMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &UserCacheMockGetParams{ctx, id}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for UserCache.Get
func (mmGet *mUserCacheMockGet) ExpectCtxParam1(ctx context.Context) *mUserCacheMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserCacheMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserCacheMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UserCacheMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UserCacheMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGet
}

// ExpectIdParam2 sets up expected param id for UserCache.Get
func (mmGet *mUserCacheMockGet) ExpectIdParam2(id int64) *mUserCacheMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserCacheMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserCacheMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UserCacheMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UserCacheMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the UserCache.Get
func (mmGet *mUserCacheMockGet) Inspect(f func(ctx context.Context, id int64)) *mUserCacheMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for UserCacheMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by UserCache.Get
func (mmGet *mUserCacheMockGet) Return(u1 model.User, err error) *UserCacheMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserCacheMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserCacheMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &UserCacheMockGetResults{u1, err}
	return mmGet.mock
}

// Set uses given function f to mock the UserCache.Get method
func (mmGet *mUserCacheMockGet) Set(f func(ctx context.Context, id int64) (u1 model.User, err error)) *UserCacheMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the UserCache.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the UserCache.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the UserCache.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mUserCacheMockGet) When(ctx context.Context, id int64) *UserCacheMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserCacheMock.Get mock is already set by Set")
	}

	expectation := &UserCacheMockGetExpectation{
		mock:   mmGet.mock,
		params: &UserCacheMockGetParams{ctx, id},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up UserCache.Get return parameters for the expectation previously defined by the When method
func (e *UserCacheMockGetExpectation) Then(u1 model.User, err error) *UserCacheMock {
	e.results = &UserCacheMockGetResults{u1, err}
	return e.mock
}

// Times sets number of times UserCache.Get should be invoked
func (mmGet *mUserCacheMockGet) Times(n uint64) *mUserCacheMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of UserCacheMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	return mmGet
}

func (mmGet *mUserCacheMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements cache.UserCache
func (mmGet *UserCacheMock) Get(ctx context.Context, id int64) (u1 model.User, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := UserCacheMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := UserCacheMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("UserCacheMock.Get got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("UserCacheMock.Get got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("UserCacheMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the UserCacheMock.Get")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to UserCacheMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished UserCacheMock.Get invocations
func (mmGet *UserCacheMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of UserCacheMock.Get invocations
func (mmGet *UserCacheMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to UserCacheMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mUserCacheMockGet) Calls() []*UserCacheMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*UserCacheMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *UserCacheMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *UserCacheMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCacheMock.Get with params: %#v", *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserCacheMock.Get")
		} else {
			m.t.Errorf("Expected call to UserCacheMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Error("Expected call to UserCacheMock.Get")
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCacheMock.Get but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), afterGetCounter)
	}
}

type mUserCacheMockSet struct {
	optional           bool
	mock               *UserCacheMock
	defaultExpectation *UserCacheMockSetExpectation
	expectations       []*UserCacheMockSetExpectation

	callArgs []*UserCacheMockSetParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// UserCacheMockSetExpectation specifies expectation struct of the UserCache.Set
type UserCacheMockSetExpectation struct {
	mock      *UserCacheMock
	params    *UserCacheMockSetParams
	paramPtrs *UserCacheMockSetParamPtrs
	results   *UserCacheMockSetResults
	Counter   uint64
}

// UserCacheMockSetParams contains parameters of the UserCache.Set
type UserCacheMockSetParams struct {
	ctx  context.Context
	user model.User
}

// UserCacheMockSetParamPtrs contains pointers to parameters of the UserCache.Set
type UserCacheMockSetParamPtrs struct {
	ctx  *context.Context
	user *model.User
}

// UserCacheMockSetResults contains results of the UserCache.Set
type UserCacheMockSetResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSet *mUserCacheMockSet) Optional() *mUserCacheMockSet {
	mmSet.optional = true
	return mmSet
}

// Expect sets up expected params for UserCache.Set
func (mmSet *mUserCacheMockSet) Expect(ctx context.Context, user model.User) *mUserCacheMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("UserCacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &UserCacheMockSetExpectation{}
	}

	if mmSet.defaultExpectation.paramPtrs != nil {
		mmSet.mock.t.Fatalf("UserCacheMock.Set mock is already set by ExpectParams functions")
	}

	mmSet.defaultExpectation.params = &UserCacheMockSetParams{ctx, user}
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// ExpectCtxParam1 sets up expected param ctx for UserCache.Set
func (mmSet *mUserCacheMockSet) ExpectCtxParam1(ctx context.Context) *mUserCacheMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("UserCacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &UserCacheMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("UserCacheMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &UserCacheMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSet
}

// ExpectUserParam2 sets up expected param user for UserCache.Set
func (mmSet *mUserCacheMockSet) ExpectUserParam2(user model.User) *mUserCacheMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("UserCacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &UserCacheMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("UserCacheMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &UserCacheMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.user = &user

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the UserCache.Set
func (mmSet *mUserCacheMockSet) Inspect(f func(ctx context.Context, user model.User)) *mUserCacheMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for UserCacheMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by UserCache.Set
func (mmSet *mUserCacheMockSet) Return(err error) *UserCacheMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("UserCacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &UserCacheMockSetExpectation{mock: mmSet.mock}
	}
	mmSet.defaultExpectation.results = &UserCacheMockSetResults{err}
	return mmSet.mock
}

// Set uses given function f to mock the UserCache.Set method
func (mmSet *mUserCacheMockSet) Set(f func(ctx context.Context, user model.User) (err error)) *UserCacheMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the UserCache.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the UserCache.Set method")
	}

	mmSet.mock.funcSet = f
	return mmSet.mock
}

// When sets expectation for the UserCache.Set which will trigger the result defined by the following
// Then helper
func (mmSet *mUserCacheMockSet) When(ctx context.Context, user model.User) *UserCacheMockSetExpectation {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("UserCacheMock.Set mock is already set by Set")
	}

	expectation := &UserCacheMockSetExpectation{
		mock:   mmSet.mock,
		params: &UserCacheMockSetParams{ctx, user},
	}
	mmSet.expectations = append(mmSet.expectations, expectation)
	return expectation
}

// Then sets up UserCache.Set return parameters for the expectation previously defined by the When method
func (e *UserCacheMockSetExpectation) Then(err error) *UserCacheMock {
	e.results = &UserCacheMockSetResults{err}
	return e.mock
}

// Times sets number of times UserCache.Set should be invoked
func (mmSet *mUserCacheMockSet) Times(n uint64) *mUserCacheMockSet {
	if n == 0 {
		mmSet.mock.t.Fatalf("Times of UserCacheMock.Set mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSet.expectedInvocations, n)
	return mmSet
}

func (mmSet *mUserCacheMockSet) invocationsDone() bool {
	if len(mmSet.expectations) == 0 && mmSet.defaultExpectation == nil && mmSet.mock.funcSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSet.mock.afterSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Set implements cache.UserCache
func (mmSet *UserCacheMock) Set(ctx context.Context, user model.User) (err error) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(ctx, user)
	}

	mm_params := UserCacheMockSetParams{ctx, user}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, &mm_params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		mm_want := mmSet.SetMock.defaultExpectation.params
		mm_want_ptrs := mmSet.SetMock.defaultExpectation.paramPtrs

		mm_got := UserCacheMockSetParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSet.t.Errorf("UserCacheMock.Set got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmSet.t.Errorf("UserCacheMock.Set got unexpected parameter user, want: %#v, got: %#v%s\n", *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSet.t.Errorf("UserCacheMock.Set got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSet.SetMock.defaultExpectation.results
		if mm_results == nil {
			mmSet.t.Fatal("No results are set for the UserCacheMock.Set")
		}
		return (*mm_results).err
	}
	if mmSet.funcSet != nil {
		return mmSet.funcSet(ctx, user)
	}
	mmSet.t.Fatalf("Unexpected call to UserCacheMock.Set. %v %v", ctx, user)
	return
}

// SetAfterCounter returns a count of finished UserCacheMock.Set invocations
func (mmSet *UserCacheMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of UserCacheMock.Set invocations
func (mmSet *UserCacheMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to UserCacheMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mUserCacheMockSet) Calls() []*UserCacheMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*UserCacheMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *UserCacheMock) MinimockSetDone() bool {
	if m.SetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetMock.invocationsDone()
}

// MinimockSetInspect logs each unmet expectation
func (m *UserCacheMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCacheMock.Set with params: %#v", *e.params)
		}
	}

	afterSetCounter := mm_atomic.LoadUint64(&m.afterSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && afterSetCounter < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserCacheMock.Set")
		} else {
			m.t.Errorf("Expected call to UserCacheMock.Set with params: %#v", *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && afterSetCounter < 1 {
		m.t.Error("Expected call to UserCacheMock.Set")
	}

	if !m.SetMock.invocationsDone() && afterSetCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCacheMock.Set but found %d calls",
			mm_atomic.LoadUint64(&m.SetMock.expectedInvocations), afterSetCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserCacheMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockSetInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserCacheMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserCacheMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockSetDone()
}
